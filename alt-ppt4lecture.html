<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Presentation Tool (Fixed Ratio)</title>
    <style>
        /* [ìŠ¤íƒ€ì¼] ê¸°ë³¸ ì„¤ì • */
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 0;
            background-color: #333; /* PPT í¸ì§‘ê¸°ì²˜ëŸ¼ ì–´ë‘ìš´ ë°°ê²½ */
            color: #333;
            font-family: 'Noto Sans KR', 'Apple SD Gothic Neo', 'Malgun Gothic', 'Segoe UI', sans-serif;
            overflow: hidden; 
            user-select: none; 
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* [ìŠ¬ë¼ì´ë“œ ìŠ¤í…Œì´ì§€] - í•µì‹¬: ê³ ì • í•´ìƒë„ (1280x720) */
        /* í™”ë©´ í¬ê¸°ì— ë”°ë¼ transform: scale()ë¡œ ì¡°ì ˆë¨ */
        #slide-stage {
            width: 1280px;  /* ê¸°ì¤€ ë„ˆë¹„ */
            height: 720px; /* ê¸°ì¤€ ë†’ì´ (16:9) */
            background-color: white;
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5); /* ê·¸ë¦¼ì */
            transform-origin: center center; /* ì¤‘ì•™ ê¸°ì¤€ í™•ëŒ€/ì¶•ì†Œ */
            overflow: hidden; /* ìŠ¬ë¼ì´ë“œ ë°–ìœ¼ë¡œ ë‚˜ê°„ ë‚´ìš© ìˆ¨ê¹€ */
        }

        /* ë“œë˜ê·¸ ì•¤ ë“œë¡­ í™œì„±í™” ì‹œ íš¨ê³¼ (ìŠ¤í…Œì´ì§€ì— ì ìš©) */
        #slide-stage.drag-over {
            border: 5px dashed #2196f3;
            background-color: #f0f8ff;
        }

        /* [ìŠ¬ë¼ì´ë“œ] ê°œë³„ í˜ì´ì§€ */
        .slide {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
        }
        .slide.active { display: block; }

        /* [ì´ë¯¸ì§€] ë“œë˜ê·¸ ë° ë¦¬ì‚¬ì´ì¦ˆ ê°€ëŠ¥ ìŠ¤íƒ€ì¼ */
        .draggable-img {
            position: absolute; 
            cursor: move; 
            border: 2px solid transparent; 
            min-width: 50px;
            min-height: 50px;
        }
        
        .draggable-img.selected {
            border: 2px solid #007bff; 
            z-index: 1000; 
        }

        .resize-handle {
            width: 15px; height: 15px;
            background: #007bff;
            position: absolute;
            right: -5px; bottom: -5px;
            cursor: se-resize; 
            display: none; 
            z-index: 1001;
        }
        .draggable-img.selected .resize-handle {
            display: block; 
        }

        .draggable-iframe iframe {
            pointer-events: none;
        }

        body.is-fullscreen .draggable-iframe iframe {
            pointer-events: auto;
        }

        /* [ì™¸ë¶€ HTML - iframe] ì°½ ì•ˆì˜ ì°½ ìŠ¤íƒ€ì¼ */
        /* ìŠ¬ë¼ì´ë“œ í¬ê¸°(1280x720) ê¸°ì¤€ìœ¼ë¡œ ë°°ì¹˜ */
        .iframe-container {
            width: 100%; 
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            background: white;
        }

        iframe {
            width: 100%; height: 100%;
            border: none;
            display: block;
        }

        /* [í…ìŠ¤íŠ¸] ê°€ì´ë“œ ë¬¸êµ¬ */
        .guide-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #999;
            pointer-events: none; 
            width: 80%;
        }
        .guide-text h1 { font-size: 40px; margin-bottom: 20px; color: #555; }
        .guide-text p { font-size: 20px; line-height: 1.6; }

        /* [HTML ì•Œë¦¼ë°”] */
        .iframe-notice {
            position: absolute;
            top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: auto;
            z-index: 2000;
        }

        /* [UI] ìƒë‹¨ ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        #ui-controls {
            position: fixed;
            top: 20px; right: 20px;
            z-index: 9999;
            display: flex;
            gap: 10px;
            transition: opacity 0.3s;
        }
        button {
            padding: 10px 20px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button:hover { background: #666; }
        #save-btn { background: #28a745; border-color: #28a745; display: none; } 
        #fs-btn { background: #007bff; border-color: #007bff; }

        /* [UI] í˜ì´ì§€ ë²ˆí˜¸ */
        #page-indicator {
            position: absolute;
            bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            z-index: 9998;
            transition: opacity 0.3s;
        }

        body:not(.is-fullscreen) #page-indicator {
            bottom: 180px;
        }

        /* [ìŠ¬ë¼ì´ë“œ ì¸ë„¤ì¼ ìŠ¤íŠ¸ë¦½] */
        #thumbnail-strip {
            position: fixed;
            left: 20px;
            right: 20px;
            bottom: 20px;
            height: 140px;
            display: flex;
            gap: 12px;
            padding: 12px;
            overflow-x: auto;
            overflow-y: hidden;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 14px;
            z-index: 9500;
            backdrop-filter: blur(8px);
        }

        #thumbnail-strip::-webkit-scrollbar {
            height: 10px;
        }
        #thumbnail-strip::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.08);
            border-radius: 10px;
        }
        #thumbnail-strip::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.35);
            border-radius: 10px;
        }

        .thumbnail {
            flex: 0 0 auto;
            width: 192px;
            height: 108px;
            position: relative;
            border-radius: 8px;
            border: 2px solid transparent;
            overflow: hidden;
            background: #222;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }

        .thumbnail.active {
            border-color: #32a3ff;
            box-shadow: 0 0 0 2px rgba(50,163,255,0.4), 0 6px 12px rgba(0,0,0,0.5);
        }

        .thumbnail-inner {
            width: 1280px;
            height: 720px;
            transform: scale(0.15);
            transform-origin: top left;
            pointer-events: none;
            position: relative;
        }

        .thumbnail .slide {
            display: block;
        }

        .thumbnail-iframe-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f1f1f1;
            color: #666;
            font-size: 40px;
            border: 4px dashed #bbb;
        }

        .thumbnail-label {
            position: absolute;
            left: 6px;
            top: 6px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
        }

        /* [ë„¤ë¹„ê²Œì´ì…˜] ì–‘ìª½ ì˜ì—­ (í™”ë©´ ì „ì²´ ë†’ì´) */
        .nav-zone {
            position: fixed;
            top: 0;
            height: 100%;
            width: 80px; 
            z-index: 9000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0; 
            transition: opacity 0.3s ease;
            cursor: pointer;
            color: rgba(255,255,255,0.5);
            font-size: 60px;
            font-weight: bold;
        }
        
        .nav-zone:hover {
            opacity: 1;
            background: linear-gradient(to right, rgba(0,0,0,0.5), transparent);
        }
        #nav-next.nav-zone:hover {
            background: linear-gradient(to left, rgba(0,0,0,0.5), transparent);
        }
        
        #nav-prev { left: 0; }
        #nav-next { right: 0; }

        /* [ì „ì²´í™”ë©´ ëª¨ë“œ ìŠ¤íƒ€ì¼] */
        body.is-fullscreen #ui-controls,
        body.is-fullscreen #page-indicator,
        body.is-fullscreen #thumbnail-strip,
        body.is-fullscreen .resize-handle,
        body.is-fullscreen .iframe-notice { display: none !important; }
        
        body.is-fullscreen .draggable-img.selected {
            border-color: transparent !important;
        }
        
        body.is-fullscreen .draggable-img {
            cursor: default !important; 
        }
        
        body.is-fullscreen {
            background-color: black; /* ë°œí‘œ ì‹œì—” ì™„ì „ ê²€ì • */
        }

    </style>
</head>
<body>

    <!-- ì–‘ìª½ ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼ -->
    <div id="nav-prev" class="nav-zone" onclick="prevSlide()">â®</div>
    <div id="nav-next" class="nav-zone" onclick="nextSlide()">â¯</div>

    <!-- ìƒë‹¨ UI ì»¨íŠ¸ë¡¤ -->
    <div id="ui-controls">
        <button id="fs-btn" onclick="startPresentation()">ğŸ–¥ï¸ ë°œí‘œ ì‹œì‘</button>
        <button onclick="addNewSlide()">+ ìƒˆ ìŠ¬ë¼ì´ë“œ</button>
        <button onclick="deleteCurrentSlide()">í˜„ì¬ ìŠ¬ë¼ì´ë“œ ì‚­ì œ</button>
        <button onclick="deleteSelectedImage()">ì‚­ì œ (Del)</button>
        <button onclick="triggerPackageLoad()">ğŸ“‚ íŒ¨í‚¤ì§€ ì—´ê¸°</button>
        <button id="save-btn" onclick="savePackage()">ğŸ“¦ íŒ¨í‚¤ì§€ ì €ì¥</button>
    </div>

    <!-- ìŠ¬ë¼ì´ë“œ ìŠ¤í…Œì´ì§€ (1280x720 ê³ ì • ë¹„ìœ¨) -->
    <div id="slide-stage">
        <!-- [1í˜ì´ì§€] -->
        <div class="slide active">
            <div class="guide-text">
                <h1>16:9 ê³ ì • ìº”ë²„ìŠ¤</h1>
                <p>ì´ì œ PPTì²˜ëŸ¼ ì‘ì—…í•˜ì„¸ìš”.</p>
                <p>ì´ í°ìƒ‰ ë°•ìŠ¤ê°€ <b>ìŠ¬ë¼ì´ë“œ ì˜ì—­</b>ì…ë‹ˆë‹¤.</p>
                <p>ì´ë¯¸ì§€ì™€ HTML íŒŒì¼ì„ ë“œë˜ê·¸í•˜ë©´ <b>íŒ¨í‚¤ì§€ë¡œ ì €ì¥</b>ë©ë‹ˆë‹¤.</p>
                <p>Shift/Alt ë“œë˜ê·¸ëŠ” <b>ì§€ì› íŒŒì¼ë§Œ ì¶”ê°€</b>í•©ë‹ˆë‹¤.</p>
            </div>
        </div>
    </div>

    <div id="page-indicator">1 / 1</div>
    <div id="thumbnail-strip" aria-label="ìŠ¬ë¼ì´ë“œ ë¯¸ë¦¬ë³´ê¸°"></div>
    <input type="file" id="package-input" accept=".altppt,.zip" style="display:none" />

    <script>
        // === ì½”ë“œ êµ¬ì¡° ===
        // ìƒíƒœ/DOM ì°¸ì¡° -> ìœ í‹¸ -> ì—ì…‹/íŒ¨í‚¤ì§€ -> ì¸ë„¤ì¼ -> ìŠ¬ë¼ì´ë“œ/ìŠ¤ì¼€ì¼
        // ì…ë ¥/ë“œë˜ê·¸ -> ìš”ì†Œ ìƒì„± -> ì €ì¥/ë¡œë“œ -> ì „ì²´í™”ë©´ -> ì´ˆê¸°í™”

        // === ìƒíƒœ/DOM ì°¸ì¡° ===
        const CONFIG = {
            STAGE_WIDTH: 1280,
            STAGE_HEIGHT: 720,
            IMAGE_DIR: 'assets',
            PACKAGE_EXTENSION: 'altppt',
            THUMB_SCALE: 0.15
        };

        const dom = {
            indicator: document.getElementById('page-indicator'),
            saveBtn: document.getElementById('save-btn'),
            thumbnailStrip: document.getElementById('thumbnail-strip'),
            packageInput: document.getElementById('package-input'),
            stage: document.getElementById('slide-stage')
        };

        const state = {
            currentScale: 1, // í˜„ì¬ í™”ë©´ ë°°ìœ¨
            currentSlideIndex: 0,
            slides: dom.stage.querySelectorAll('.slide'),
            selectedImage: null,
            packageFiles: new Map(),
            requiredAssets: new Set(),
            imageCounter: 1,
            fileCounter: 1,
            clipboardImage: null,
            thumbnailRefreshPending: false,
            lastSaveHandle: null,
            lastPackageFileName: ''
        };

        function refreshSlides() {
            state.slides = dom.stage.querySelectorAll('.slide');
            return state.slides;
        }

        function getActiveSlide() {
            const slides = refreshSlides();
            return slides[state.currentSlideIndex] || null;
        }

        function removeGuideText(slide) {
            if (!slide) return;
            const guideText = slide.querySelector('.guide-text');
            if (guideText) guideText.remove();
        }

        // === ê²½ë¡œ/íŒŒì¼ ìœ í‹¸ ===
        function sanitizeFileName(name) {
            const base = (name || '').split(/[\\/]/).pop();
            return base.replace(/[<>:"|?*]/g, '_').trim();
        }

        function splitName(name) {
            const clean = name || '';
            const dot = clean.lastIndexOf('.');
            if (dot <= 0) return { base: clean || 'file', ext: '' };
            return { base: clean.slice(0, dot), ext: clean.slice(dot) };
        }

        function splitPath(path) {
            const normalized = path || '';
            const slash = normalized.lastIndexOf('/');
            const dir = slash === -1 ? '' : normalized.slice(0, slash + 1);
            const file = slash === -1 ? normalized : normalized.slice(slash + 1);
            const { base, ext } = splitName(file);
            return { dir, base, ext };
        }

        function parseDataUrl(value) {
            if (!value || typeof value !== 'string') return null;
            if (!value.startsWith('data:')) return null;
            const commaIndex = value.indexOf(',');
            if (commaIndex === -1) return null;
            const meta = value.slice(5, commaIndex);
            const data = value.slice(commaIndex + 1);
            const parts = meta.split(';').filter(Boolean);
            const mime = parts[0] || 'application/octet-stream';
            const isBase64 = parts.includes('base64');
            return { mime, isBase64, data };
        }

        function decodeBase64ToUint8Array(base64) {
            const cleaned = (base64 || '').replace(/\s+/g, '');
            const binary = atob(cleaned);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        function convertEmbeddedImagesInDocument(doc, cache) {
            if (!doc) return 0;
            let converted = 0;
            const images = doc.querySelectorAll('img[src^="data:"]');

            images.forEach((img) => {
                const src = img.getAttribute('src');
                const parsed = parseDataUrl(src);
                if (!parsed || !parsed.isBase64 || !parsed.mime.startsWith('image/')) return;

                if (cache && cache.has(src)) {
                    img.setAttribute('src', './' + cache.get(src));
                    converted += 1;
                    return;
                }

                try {
                    const bytes = decodeBase64ToUint8Array(parsed.data);
                    const blob = new Blob([bytes], { type: parsed.mime });
                    const assetPath = registerImageAsset(blob, '');
                    if (cache) cache.set(src, assetPath);
                    img.setAttribute('src', './' + assetPath);
                    converted += 1;
                } catch (err) {
                    // ë³€í™˜ ì‹¤íŒ¨ ì‹œ ì›ë³¸ data URL ìœ ì§€
                }
            });

            return converted;
        }

        function convertBase64ImagesInHtml(htmlText, cache) {
            if (!htmlText) return { html: htmlText, converted: 0 };
            const doc = new DOMParser().parseFromString(htmlText, 'text/html');
            const converted = convertEmbeddedImagesInDocument(doc, cache);
            if (!converted) return { html: htmlText, converted: 0 };
            return { html: doc.documentElement.outerHTML, converted };
        }

        function stripExtensionFromName(name, extension) {
            const safeName = sanitizeFileName(name || '');
            if (!safeName) return '';
            if (extension) {
                const suffix = `.${extension.toLowerCase()}`;
                if (safeName.toLowerCase().endsWith(suffix)) {
                    return safeName.slice(0, -suffix.length);
                }
            }
            const { base } = splitName(safeName);
            return base;
        }

        function applyTitleToClone(clone, titleText) {
            if (!clone) return;
            const head = clone.querySelector('head');
            if (!head) return;
            let title = head.querySelector('title');
            if (!title) {
                title = document.createElement('title');
                head.appendChild(title);
            }
            title.textContent = titleText;
        }

        function sanitizePath(path) {
            const normalized = (path || '').replace(/\\/g, '/');
            const parts = normalized.split('/').filter(Boolean);
            const safeParts = parts
                .filter(part => part !== '.' && part !== '..')
                .map(part => part.replace(/[<>:"|?*]/g, '_'));
            return safeParts.join('/');
        }

        function ensurePackageExtension(name) {
            const safeName = sanitizeFileName(name || '');
            if (!safeName) return '';
            const lower = safeName.toLowerCase();
            const ext = `.${CONFIG.PACKAGE_EXTENSION}`;
            if (lower.endsWith(ext)) return safeName;
            const { base } = splitName(safeName);
            return `${base}${ext}`;
        }

        function uniquePath(path) {
            const safePath = sanitizePath(path);
            const fallback = `file_${String(state.fileCounter++).padStart(3, '0')}`;
            const { dir, base, ext } = splitPath(safePath || fallback);
            let candidate = `${dir}${base}${ext}`;
            let index = 1;
            while (state.packageFiles.has(candidate)) {
                candidate = `${dir}${base}-${index}${ext}`;
                index += 1;
            }
            return candidate;
        }

        function inferImageExtension(name, type) {
            const extFromName = splitName(sanitizeFileName(name)).ext.toLowerCase();
            if (extFromName) return extFromName.replace('.', '');
            const typeMap = {
                'image/png': 'png',
                'image/jpeg': 'jpg',
                'image/jpg': 'jpg',
                'image/gif': 'gif',
                'image/webp': 'webp',
                'image/svg+xml': 'svg',
                'image/bmp': 'bmp',
                'image/x-icon': 'ico'
            };
            return typeMap[type] || 'png';
        }

        function normalizeAssetPath(value) {
            if (!value) return null;
            const trimmed = value.trim();
            if (!trimmed) return null;
            const cleaned = trimmed.split('#')[0].split('?')[0];
            if (!cleaned) return null;
            if (/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(cleaned)) return null;
            const withoutLeading = cleaned.replace(/^\.\//, '').replace(/^\//, '');
            if (withoutLeading.startsWith('..')) return null;
            const safePath = sanitizePath(withoutLeading);
            return safePath || null;
        }

        function extractSrcsetPaths(srcsetValue, assets) {
            if (!srcsetValue) return;
            const candidates = srcsetValue.split(',');
            for (const candidate of candidates) {
                const url = candidate.trim().split(/\s+/)[0];
                const normalized = normalizeAssetPath(url);
                if (normalized) assets.add(normalized);
            }
        }

        // === ì—ì…‹/íŒ¨í‚¤ì§€ ë“±ë¡ ===
        function extractRequiredAssetsFromHtml(htmlText) {
            const assets = new Set();
            const doc = new DOMParser().parseFromString(htmlText, 'text/html');

            doc.querySelectorAll('[src]').forEach((el) => {
                const normalized = normalizeAssetPath(el.getAttribute('src'));
                if (normalized) assets.add(normalized);
                if (el.hasAttribute('srcset')) {
                    extractSrcsetPaths(el.getAttribute('srcset'), assets);
                }
            });

            doc.querySelectorAll('link[href]').forEach((el) => {
                const normalized = normalizeAssetPath(el.getAttribute('href'));
                if (normalized) assets.add(normalized);
            });

            doc.querySelectorAll('source[srcset]').forEach((el) => {
                extractSrcsetPaths(el.getAttribute('srcset'), assets);
            });

            return assets;
        }

        function registerRequiredAssetsFromHtml(htmlText) {
            extractRequiredAssetsFromHtml(htmlText).forEach(asset => state.requiredAssets.add(asset));
        }

        function matchRequiredAssetPath(fileName) {
            if (!fileName) return null;
            const matches = [];
            state.requiredAssets.forEach((asset) => {
                if (asset.split('/').pop() === fileName && !state.packageFiles.has(asset)) matches.push(asset);
            });
            return matches.length === 1 ? matches[0] : null;
        }

        function registerImageAsset(blob, preferredName) {
            const extension = inferImageExtension(preferredName, blob.type || '');
            let baseName = sanitizeFileName(preferredName || '');
            if (!baseName) {
                baseName = `image_${String(state.imageCounter++).padStart(3, '0')}.${extension}`;
            } else if (!baseName.includes('.')) {
                baseName = `${baseName}.${extension}`;
            }
            const assetPath = uniquePath(`${CONFIG.IMAGE_DIR}/${baseName}`);
            state.packageFiles.set(assetPath, blob);
            return assetPath;
        }

        function registerSupportFile(file) {
            const fileName = sanitizeFileName(file.name || '');
            const relativePath = sanitizePath(file.webkitRelativePath || '');
            const matchedPath = relativePath ? null : matchRequiredAssetPath(fileName);
            const rawPath = matchedPath || relativePath || fileName;
            const unique = uniquePath(rawPath || `file_${String(state.fileCounter++).padStart(3, '0')}`);
            state.packageFiles.set(unique, file);
            return unique;
        }

        function getMissingAssets() {
            const missing = [];
            state.requiredAssets.forEach((asset) => {
                if (!state.packageFiles.has(asset)) missing.push(asset);
            });
            return missing;
        }

        function removeImageAssetIfUnused(assetPath) {
            if (!assetPath) return;
            const stillUsed = Array.from(document.querySelectorAll('img[data-asset-path]'))
                .some((img) => img.dataset.assetPath === assetPath);
            const usedByClipboard = state.clipboardImage && state.clipboardImage.assetPath === assetPath;
            if (!stillUsed && !usedByClipboard) state.packageFiles.delete(assetPath);
        }

        function removeHtmlAssetIfUnused(fileName) {
            if (!fileName) return;
            const stillUsed = Array.from(document.querySelectorAll('iframe'))
                .some((iframe) => iframe.dataset.filename === fileName);
            if (!stillUsed) state.packageFiles.delete(fileName);
        }

        // === íŒ¨í‚¤ì§€ ë¡œë“œ ===
        function triggerPackageLoad() {
            if (!dom.packageInput) return;
            dom.packageInput.value = '';
            dom.packageInput.click();
        }

        function guessMimeType(name) {
            const lower = (name || '').toLowerCase();
            if (lower.endsWith('.png')) return 'image/png';
            if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
            if (lower.endsWith('.gif')) return 'image/gif';
            if (lower.endsWith('.webp')) return 'image/webp';
            if (lower.endsWith('.svg')) return 'image/svg+xml';
            if (lower.endsWith('.bmp')) return 'image/bmp';
            if (lower.endsWith('.ico')) return 'image/x-icon';
            if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'text/html';
            if (lower.endsWith('.css')) return 'text/css';
            if (lower.endsWith('.js')) return 'text/javascript';
            if (lower.endsWith('.json')) return 'application/json';
            return 'application/octet-stream';
        }

        function parseZipEntries(buffer) {
            const data = new Uint8Array(buffer);
            const view = new DataView(buffer);
            let eocdOffset = -1;

            for (let i = data.length - 22; i >= 0; i--) {
                if (data[i] === 0x50 && data[i + 1] === 0x4b && data[i + 2] === 0x05 && data[i + 3] === 0x06) {
                    eocdOffset = i;
                    break;
                }
            }

            if (eocdOffset < 0) throw new Error('íŒ¨í‚¤ì§€ ëì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');

            const centralDirSize = view.getUint32(eocdOffset + 12, true);
            const centralDirOffset = view.getUint32(eocdOffset + 16, true);
            const centralDirEnd = centralDirOffset + centralDirSize;
            let offset = centralDirOffset;
            const entries = [];

            while (offset < centralDirEnd) {
                if (view.getUint32(offset, true) !== 0x02014b50) break;
                const compression = view.getUint16(offset + 10, true);
                const nameLen = view.getUint16(offset + 28, true);
                const extraLen = view.getUint16(offset + 30, true);
                const commentLen = view.getUint16(offset + 32, true);
                const localHeaderOffset = view.getUint32(offset + 42, true);
                const nameBytes = data.slice(offset + 46, offset + 46 + nameLen);
                const name = textDecoder.decode(nameBytes);
                entries.push({ name, compression, localHeaderOffset });
                offset += 46 + nameLen + extraLen + commentLen;
            }

            const files = new Map();
            for (const entry of entries) {
                if (!entry.name || entry.name.endsWith('/')) continue;
                if (entry.compression !== 0) {
                    throw new Error('ì••ì¶•ëœ ZIPì€ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                }

                const localOffset = entry.localHeaderOffset;
                if (view.getUint32(localOffset, true) !== 0x04034b50) continue;
                const nameLen = view.getUint16(localOffset + 26, true);
                const extraLen = view.getUint16(localOffset + 28, true);
                const dataOffset = localOffset + 30 + nameLen + extraLen;
                const dataSize = view.getUint32(localOffset + 18, true);
                const fileData = data.slice(dataOffset, dataOffset + dataSize);
                files.set(entry.name, fileData);
            }

            return files;
        }

        function findMainHtml(files) {
            const htmlEntries = [];
            for (const [name, data] of files.entries()) {
                if (name.toLowerCase().endsWith('.html') || name.toLowerCase().endsWith('.htm')) {
                    htmlEntries.push({ name, data });
                }
            }

            for (const entry of htmlEntries) {
                const text = textDecoder.decode(entry.data);
                const doc = new DOMParser().parseFromString(text, 'text/html');
                if (doc.querySelector('#slide-stage') && doc.querySelector('.slide')) {
                    return { name: entry.name, html: text };
                }
            }

            if (htmlEntries.length > 0) {
                const fallback = htmlEntries[0];
                return { name: fallback.name, html: textDecoder.decode(fallback.data) };
            }
            return null;
        }

        async function loadPackageFromFile(file) {
            if (!file) return;
            const proceed = confirm("í˜„ì¬ ì‘ì—…ì„ ë®ì–´ì“°ê³  íŒ¨í‚¤ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ê¹Œìš”?");
            if (!proceed) return;

            let files;
            try {
                const buffer = await file.arrayBuffer();
                files = parseZipEntries(buffer);
            } catch (err) {
                alert(`íŒ¨í‚¤ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n${err.message}`);
                return;
            }

            const main = findMainHtml(files);
            if (!main) {
                alert("í”„ë ˆì  í…Œì´ì…˜ HTMLì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
                return;
            }

            state.packageFiles.clear();
            state.requiredAssets.clear();
            state.clipboardImage = null;
            state.selectedImage = null;
            state.imageCounter = 1;
            state.fileCounter = 1;
            state.lastSaveHandle = null;
            state.lastPackageFileName = ensurePackageExtension(file.name || '');
            const embeddedImageCache = new Map();
            let legacyConvertedCount = 0;

            for (const [name, data] of files.entries()) {
                if (name === main.name) continue;
                const blob = new Blob([data], { type: guessMimeType(name) });

                if (name.toLowerCase().endsWith('.html') || name.toLowerCase().endsWith('.htm')) {
                    try {
                        const text = await blob.text();
                        const converted = convertBase64ImagesInHtml(text, embeddedImageCache);
                        if (converted.converted > 0) {
                            legacyConvertedCount += converted.converted;
                            state.packageFiles.set(name, new Blob([converted.html], { type: 'text/html' }));
                            registerRequiredAssetsFromHtml(converted.html);
                        } else {
                            state.packageFiles.set(name, blob);
                            registerRequiredAssetsFromHtml(text);
                        }
                    } catch (err) {
                        state.packageFiles.set(name, blob);
                    }
                } else {
                    state.packageFiles.set(name, blob);
                }
            }

            const parsedDoc = new DOMParser().parseFromString(main.html, 'text/html');
            legacyConvertedCount += convertEmbeddedImagesInDocument(parsedDoc, embeddedImageCache);
            const updatedMainHtml = parsedDoc.documentElement.outerHTML;
            registerRequiredAssetsFromHtml(updatedMainHtml);
            const parsedStage = parsedDoc.querySelector('#slide-stage');
            if (!parsedStage) {
                alert("ìŠ¬ë¼ì´ë“œ ë°ì´í„°ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
                return;
            }

            const parsedTitle = (parsedDoc.title || '').trim();
            const mainTitle = stripExtensionFromName(main.name, 'html');
            const fallbackTitle = stripExtensionFromName(file.name, CONFIG.PACKAGE_EXTENSION);
            document.title = parsedTitle || mainTitle || fallbackTitle || document.title;

            const stage = dom.stage;
            stage.innerHTML = '';
            const parsedSlides = parsedStage.querySelectorAll('.slide');
            parsedSlides.forEach((slide, index) => {
                const newSlide = document.createElement('div');
                newSlide.className = 'slide';
                if (slide.classList.contains('iframe-slide')) newSlide.classList.add('iframe-slide');
                if (index === 0) newSlide.classList.add('active');
                newSlide.innerHTML = slide.innerHTML;
                stage.appendChild(newSlide);
            });

            const slides = refreshSlides();
            slides.forEach((slide) => {
                slide.querySelectorAll('.draggable-img').forEach((wrapper) => {
                    wrapper.classList.remove('selected');
                    let handle = wrapper.querySelector('.resize-handle');
                    if (!handle) {
                        handle = document.createElement('div');
                        handle.className = 'resize-handle';
                        wrapper.appendChild(handle);
                    }
                    setupInteraction(wrapper, handle);

                    const img = wrapper.querySelector('img');
                    if (!img) return;
                    const assetPath = normalizeAssetPath(img.getAttribute('src'));
                    if (!assetPath || !state.packageFiles.has(assetPath)) return;
                    const blob = state.packageFiles.get(assetPath);
                    const url = URL.createObjectURL(blob);
                    img.src = url;
                    img.dataset.assetPath = assetPath;
                    img.addEventListener('load', () => URL.revokeObjectURL(url), { once: true });
                    img.addEventListener('error', () => URL.revokeObjectURL(url), { once: true });
                });

                slide.querySelectorAll('iframe').forEach((iframe) => {
                    const srcPath = normalizeAssetPath(iframe.getAttribute('src')) || iframe.dataset.filename;
                    if (!srcPath || !state.packageFiles.has(srcPath)) return;
                    const blob = state.packageFiles.get(srcPath);
                    const url = URL.createObjectURL(blob);
                    iframe.dataset.filename = srcPath;
                    iframe.src = url;
                    iframe.addEventListener('load', () => URL.revokeObjectURL(url), { once: true });
                });
            });

            state.currentSlideIndex = 0;
            updateSlideVisibility();
            renderThumbnails();
            showSaveButton();
            resizeStage();

            if (legacyConvertedCount > 0) {
                alert(`ë ˆê±°ì‹œ base64 ì´ë¯¸ì§€ ${legacyConvertedCount}ê°œë¥¼ ì—ì…‹ìœ¼ë¡œ ë³€í™˜í–ˆìŠµë‹ˆë‹¤.\nì €ì¥í•˜ë©´ ìµœì‹  íŒ¨í‚¤ì§€ë¡œ ì •ë¦¬ë©ë‹ˆë‹¤.`);
            }
        }

        // === ì¸ë„¤ì¼ ===
        function scheduleThumbnailRefresh() {
            if (!dom.thumbnailStrip) return;
            if (state.thumbnailRefreshPending) return;
            state.thumbnailRefreshPending = true;
            requestAnimationFrame(() => {
                state.thumbnailRefreshPending = false;
                renderThumbnails();
            });
        }

        function renderThumbnails() {
            if (!dom.thumbnailStrip) return;
            const slides = refreshSlides();
            dom.thumbnailStrip.innerHTML = '';

            slides.forEach((slide, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'thumbnail';
                thumb.dataset.index = index;
                thumb.setAttribute('role', 'button');
                thumb.tabIndex = 0;

                const inner = document.createElement('div');
                inner.className = 'thumbnail-inner';
                inner.style.transform = `scale(${CONFIG.THUMB_SCALE})`;

                const clone = slide.cloneNode(true);
                clone.classList.remove('active');
                clone.querySelectorAll('.resize-handle').forEach(el => el.remove());
                clone.querySelectorAll('.draggable-img').forEach(el => el.classList.remove('selected'));
                clone.querySelectorAll('img[data-asset-path]').forEach((img) => {
                    const assetPath = img.dataset.assetPath;
                    if (!assetPath || !state.packageFiles.has(assetPath)) return;
                    const blob = state.packageFiles.get(assetPath);
                    const url = URL.createObjectURL(blob);
                    img.src = url;
                    img.addEventListener('load', () => URL.revokeObjectURL(url), { once: true });
                    img.addEventListener('error', () => URL.revokeObjectURL(url), { once: true });
                });
                clone.querySelectorAll('iframe').forEach((iframe) => {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'thumbnail-iframe-placeholder';
                    const label = iframe.dataset.filename || 'HTML';
                    placeholder.textContent = label;
                    iframe.replaceWith(placeholder);
                });
                clone.querySelectorAll('.iframe-notice').forEach(el => el.remove());

                inner.appendChild(clone);
                thumb.appendChild(inner);

                const label = document.createElement('div');
                label.className = 'thumbnail-label';
                label.textContent = index + 1;
                thumb.appendChild(label);

                thumb.addEventListener('click', () => {
                    state.currentSlideIndex = index;
                    updateSlideVisibility();
                });

                thumb.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        state.currentSlideIndex = index;
                        updateSlideVisibility();
                    }
                });

                dom.thumbnailStrip.appendChild(thumb);
            });

            updateThumbnailActive();
        }

        function updateThumbnailActive() {
            if (!dom.thumbnailStrip) return;
            const thumbs = dom.thumbnailStrip.querySelectorAll('.thumbnail');
            thumbs.forEach((thumb, index) => {
                thumb.classList.toggle('active', index === state.currentSlideIndex);
            });
            const activeThumb = dom.thumbnailStrip.querySelector('.thumbnail.active');
            if (activeThumb) {
                activeThumb.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        }

        // === í´ë¦½ë³´ë“œ/ìš”ì†Œ ìƒíƒœ ===
        function getElementStyleNumber(element, prop, fallback) {
            const value = parseFloat(element.style[prop]);
            return Number.isFinite(value) ? value : fallback;
        }

        function captureImageState(wrapper) {
            const img = wrapper.querySelector('img[data-asset-path]');
            if (!img) return null;
            return {
                assetPath: img.dataset.assetPath,
                left: getElementStyleNumber(wrapper, 'left', wrapper.offsetLeft),
                top: getElementStyleNumber(wrapper, 'top', wrapper.offsetTop),
                width: getElementStyleNumber(wrapper, 'width', wrapper.offsetWidth),
                height: getElementStyleNumber(wrapper, 'height', wrapper.offsetHeight)
            };
        }

        function copySelectedImage() {
            if (!state.selectedImage) return;
            const imageState = captureImageState(state.selectedImage);
            if (!imageState) return;
            const previousAsset = state.clipboardImage ? state.clipboardImage.assetPath : null;
            state.clipboardImage = imageState;
            if (previousAsset && previousAsset !== imageState.assetPath) removeImageAssetIfUnused(previousAsset);
        }

        function createDraggableImageFromAsset(assetPath, layout = {}) {
            const activeSlide = getActiveSlide();
            if (!activeSlide) return;
            removeGuideText(activeSlide);

            const blob = state.packageFiles.get(assetPath);
            if (!blob) {
                alert("ë³µì‚¬í•œ ì´ë¯¸ì§€ ì›ë³¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në‹¤ì‹œ ë³µì‚¬í•´ì£¼ì„¸ìš”.");
                return;
            }

            const objectUrl = URL.createObjectURL(blob);

            const wrapper = document.createElement('div');
            wrapper.className = 'draggable-img selected';
            wrapper.style.left = `${Number.isFinite(layout.left) ? layout.left : 400}px`;
            wrapper.style.top = `${Number.isFinite(layout.top) ? layout.top : 200}px`;
            if (Number.isFinite(layout.width)) wrapper.style.width = `${layout.width}px`;
            if (Number.isFinite(layout.height)) wrapper.style.height = `${layout.height}px`;

            const img = document.createElement('img');
            img.src = objectUrl;
            img.dataset.assetPath = assetPath;
            img.style.width = '100%'; img.style.height = '100%';
            img.style.display = 'block'; img.ondragstart = () => false;
            img.addEventListener('load', () => URL.revokeObjectURL(objectUrl), { once: true });
            img.addEventListener('error', () => URL.revokeObjectURL(objectUrl), { once: true });
            
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            
            wrapper.appendChild(img); wrapper.appendChild(handle);
            activeSlide.appendChild(wrapper);
            
            setupInteraction(wrapper, handle);
            selectImage(wrapper);
            showSaveButton();
        }

        function pasteClipboardImage() {
            if (!state.clipboardImage) return;
            createDraggableImageFromAsset(state.clipboardImage.assetPath, state.clipboardImage);
        }

        // === ìŠ¤í…Œì´ì§€ ìŠ¤ì¼€ì¼ë§ ===
        function resizeStage() {
            const stage = dom.stage;
            
            // í™”ë©´ í¬ê¸° ëŒ€ë¹„ ìŠ¤í…Œì´ì§€ ë¹„ìœ¨ ê³„ì‚° (ì—¬ë°± 40px ì •ë„ í™•ë³´)
            const availableWidth = window.innerWidth - 40;
            let availableHeight = window.innerHeight - 40;
            const isFullscreen = document.body.classList.contains('is-fullscreen');
            let offsetY = 0;
            if (!isFullscreen && dom.thumbnailStrip) {
                const reserve = dom.thumbnailStrip.offsetHeight + 30;
                availableHeight -= reserve;
                offsetY = -(reserve / 2);
            }

            const scaleX = availableWidth / CONFIG.STAGE_WIDTH;
            const scaleY = availableHeight / CONFIG.STAGE_HEIGHT;

            // ë” ì‘ì€ ë°°ìœ¨ì„ ë”°ë¼ê°€ì„œ í™”ë©´ì— ê½‰ ì°¨ê²Œ(Fit) ë§ì¶¤
            let scale = Math.min(scaleX, scaleY);
            
            // ë°œí‘œ ëª¨ë“œì¼ ë•ŒëŠ” ì—¬ë°± ì—†ì´ ê½‰ ì±„ì›€
            if (isFullscreen) {
                const fullScaleX = window.innerWidth / CONFIG.STAGE_WIDTH;
                const fullScaleY = window.innerHeight / CONFIG.STAGE_HEIGHT;
                scale = Math.min(fullScaleX, fullScaleY);
            }

            state.currentScale = scale;
            stage.style.transform = `translateY(${offsetY}px) scale(${scale})`;
        }

        // === ì´ˆê¸°í™” ===
        function init() {
            bindEvents();
            resizeStage();
            updateSlideVisibility();
            renderThumbnails();
        }

        init();


        // === ìŠ¬ë¼ì´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ===
        function updateSlideVisibility() {
            const slides = refreshSlides();
            slides.forEach((slide, index) => {
                slide.classList.remove('active');
                if (index === state.currentSlideIndex) slide.classList.add('active');
            });
            dom.indicator.textContent = `${state.currentSlideIndex + 1} / ${slides.length}`;
            deselectImage();
            updateThumbnailActive();
        }

        function nextSlide() {
            const slides = refreshSlides();
            if (state.currentSlideIndex < slides.length - 1) {
                state.currentSlideIndex++;
                updateSlideVisibility();
            }
        }

        function prevSlide() {
            if (state.currentSlideIndex > 0) {
                state.currentSlideIndex--;
                updateSlideVisibility();
            }
        }

        function addNewSlide() {
            const stage = dom.stage;
            const newSlide = document.createElement('div');
            newSlide.className = 'slide';
            const slides = refreshSlides();
            const currentSlide = slides[state.currentSlideIndex];
            if (currentSlide && currentSlide.nextSibling) {
                stage.insertBefore(newSlide, currentSlide.nextSibling);
            } else {
                stage.appendChild(newSlide);
            }
            setTimeout(() => {
                const updatedSlides = refreshSlides();
                state.currentSlideIndex = Math.min(state.currentSlideIndex + 1, updatedSlides.length - 1);
                updateSlideVisibility();
                showSaveButton();
            }, 50);
        }

        function collectSlideAssets(slide) {
            const imageAssets = new Set();
            const htmlAssets = new Set();

            slide.querySelectorAll('img[data-asset-path]').forEach((img) => {
                if (img.dataset.assetPath) imageAssets.add(img.dataset.assetPath);
            });

            slide.querySelectorAll('iframe').forEach((iframe) => {
                const fileName = iframe.dataset.filename || normalizeAssetPath(iframe.getAttribute('src'));
                if (fileName) htmlAssets.add(fileName);
            });

            return { imageAssets, htmlAssets };
        }

        function deleteCurrentSlide() {
            requestDeleteSlide(state.currentSlideIndex);
        }

        function requestDeleteSlide(index) {
            const slides = refreshSlides();
            if (!slides.length) return;
            if (index < 0 || index >= slides.length) return;

            const message = slides.length === 1
                ? 'ë§ˆì§€ë§‰ ìŠ¬ë¼ì´ë“œëŠ” ì‚­ì œí•  ìˆ˜ ì—†ì–´ ë‚´ìš©ë§Œ ë¹„ì›ë‹ˆë‹¤. ê³„ì†í• ê¹Œìš”?'
                : 'ì„ íƒí•œ ìŠ¬ë¼ì´ë“œë¥¼ ì‚­ì œí• ê¹Œìš”?';

            if (!confirm(message)) return;
            deleteSlideAtIndex(index);
        }

        function deleteSlideAtIndex(index) {
            const slides = refreshSlides();
            if (index < 0 || index >= slides.length) return;

            const slide = slides[index];
            const { imageAssets, htmlAssets } = collectSlideAssets(slide);

            if (slides.length === 1) {
                slide.innerHTML = '';
                state.currentSlideIndex = 0;
            } else {
                slide.remove();
                const updatedSlides = refreshSlides();
                if (state.currentSlideIndex > index) {
                    state.currentSlideIndex -= 1;
                } else if (state.currentSlideIndex >= updatedSlides.length) {
                    state.currentSlideIndex = updatedSlides.length - 1;
                }
            }

            deselectImage();
            imageAssets.forEach(removeImageAssetIfUnused);
            htmlAssets.forEach(removeHtmlAssetIfUnused);
            updateSlideVisibility();
            showSaveButton();
        }

        // === ì…ë ¥/ë„¤ë¹„ê²Œì´ì…˜ ì´ë²¤íŠ¸ ===
        function bindEvents() {
            window.addEventListener('resize', resizeStage);

            window.addEventListener('wheel', (e) => {
                if (dom.thumbnailStrip && dom.thumbnailStrip.contains(e.target)) return;
                if (e.deltaY > 0) nextSlide(); else prevSlide();
            });

            if (dom.thumbnailStrip) {
                dom.thumbnailStrip.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    dom.thumbnailStrip.scrollLeft += (e.deltaY + e.deltaX);
                }, { passive: false });

                dom.thumbnailStrip.addEventListener('contextmenu', (e) => {
                    const thumb = e.target.closest('.thumbnail');
                    if (!thumb) return;
                    e.preventDefault();
                    e.stopPropagation();
                    const index = Number.parseInt(thumb.dataset.index, 10);
                    if (Number.isFinite(index)) requestDeleteSlide(index);
                });
            }

            window.addEventListener('contextmenu', (e) => {
                e.preventDefault(); 
                if (document.body.classList.contains('is-fullscreen')) {
                    if (state.currentSlideIndex === 0) return;
                    prevSlide(); 
                } else {
                    nextSlide();
                }
            });

            window.addEventListener('click', (e) => {
                if (!document.body.classList.contains('is-fullscreen')) return;
                if (e.target.closest('button') || e.target.closest('.nav-zone')) return;
                if (e.target.closest('.draggable-iframe')) return;

                const slides = refreshSlides();
                if (state.currentSlideIndex >= slides.length - 1) {
                    exitPresentation();
                    state.currentSlideIndex = 0;
                    updateSlideVisibility();
                } else {
                    nextSlide();
                }
            });

            window.addEventListener('keydown', (e) => {
                const isModKey = e.ctrlKey || e.metaKey;
                const key = e.key.toLowerCase();

                if (isModKey && key === 'c' && state.selectedImage) {
                    e.preventDefault();
                    copySelectedImage();
                    return;
                }

                if (isModKey && key === 'v') {
                    if (state.clipboardImage) {
                        e.preventDefault();
                        pasteClipboardImage();
                    }
                    return;
                }

                if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') nextSlide();
                if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') prevSlide();
                if (e.key === 'Delete' && state.selectedImage) deleteSelectedImage();
            });

            if (dom.packageInput) {
                dom.packageInput.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (file) loadPackageFromFile(file);
                });
            }

            const stage = dom.stage;
            stage.addEventListener('dragenter', (e) => {
                e.preventDefault();
                stage.classList.add('drag-over');
            });

            stage.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            stage.addEventListener('dragleave', (e) => {
                if (!stage.contains(e.relatedTarget)) stage.classList.remove('drag-over');
            });

            stage.addEventListener('drop', (e) => {
                e.preventDefault();
                stage.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) handleDroppedFiles(files, { supportOnly: e.shiftKey || e.altKey });
            });

            document.addEventListener('dragover', (e) => { e.preventDefault(); });
            document.addEventListener('drop', (e) => {
                if (!stage.contains(e.target)) e.preventDefault();
                stage.classList.remove('drag-over');
            });

            window.addEventListener('paste', (e) => {
                const items = (e.clipboardData || e.originalEvent.clipboardData).items;
                for (let item of items) {
                    if (item.type.includes('image')) {
                        const blob = item.getAsFile();
                        if (blob) createDraggableImageFromBlob(blob);
                    }
                }
            });

            document.addEventListener('mousedown', (e) => {
                if (!e.target.closest('.draggable-img') && !e.target.closest('button') && !e.target.closest('.nav-zone')) deselectImage();
            });

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        }

        function handleDroppedFiles(files, options = {}) {
            const supportOnly = options.supportOnly === true;
            let addedSupport = false;

            for (const file of files) {
                const fileName = (file.name || '').toLowerCase();
                if (fileName.endsWith(`.${CONFIG.PACKAGE_EXTENSION}`) || fileName.endsWith('.zip')) {
                    loadPackageFromFile(file);
                    return;
                }

                if (supportOnly) {
                    registerSupportFile(file);
                    addedSupport = true;
                    continue;
                }

                if (file.type.startsWith('image/')) {
                    createDraggableImageFromBlob(file, file.name);
                } else if (fileName.endsWith('.html') || fileName.endsWith('.htm') || file.type === 'text/html') {
                    transformCurrentSlideToHtml(file);
                } else {
                    registerSupportFile(file);
                    addedSupport = true;
                }
            }

            if (addedSupport) showSaveButton();
        }

        function transformCurrentSlideToHtml(fileOrName) {
            const activeSlide = getActiveSlide();
            if (!activeSlide) return;
            removeGuideText(activeSlide);

            const wrapper = document.createElement('div');
            wrapper.className = 'draggable-img draggable-iframe selected';
            wrapper.style.left = '320px';
            wrapper.style.top = '180px';
            wrapper.style.width = '640px';
            wrapper.style.height = '360px';

            const iframe = document.createElement('iframe');
            let displayName = "";
            
            if (fileOrName instanceof File) {
                let baseName = sanitizeFileName(fileOrName.name || '');
                if (baseName && !baseName.includes('.')) baseName = `${baseName}.html`;
                const fallbackName = `slide_${String(state.fileCounter++).padStart(3, '0')}.html`;
                const fileName = uniquePath(baseName || fallbackName);

                state.packageFiles.set(fileName, fileOrName);
                iframe.dataset.filename = fileName;
                displayName = fileName;

                const objectUrl = URL.createObjectURL(fileOrName);
                iframe.src = objectUrl;
                iframe.addEventListener('load', () => URL.revokeObjectURL(objectUrl), { once: true });

                fileOrName.text()
                    .then(text => registerRequiredAssetsFromHtml(text))
                    .catch(() => {});
            } else {
                iframe.src = './' + fileOrName;
                displayName = fileOrName;
                iframe.dataset.filename = fileOrName;
            }

            const handle = document.createElement('div');
            handle.className = 'resize-handle';

            const notice = document.createElement('div');
            notice.className = 'iframe-notice';
            notice.textContent = `ğŸ“„ ${displayName}`;

            wrapper.appendChild(iframe);
            wrapper.appendChild(handle);
            wrapper.appendChild(notice);
            activeSlide.appendChild(wrapper);
            
            setupInteraction(wrapper, handle);
            selectImage(wrapper);
            showSaveButton();
        }

        // === í´ë¦½ë³´ë“œ ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸° ===

        function createDraggableImageFromBlob(blob, preferredName) {
            const activeSlide = getActiveSlide();
            if (!activeSlide) return;
            removeGuideText(activeSlide);

            const assetPath = registerImageAsset(blob, preferredName);
            const objectUrl = URL.createObjectURL(blob);

            const wrapper = document.createElement('div');
            wrapper.className = 'draggable-img selected'; 
            // ì¤‘ì•™ì— ë°°ì¹˜ (1280x720 ê¸°ì¤€)
            wrapper.style.left = '400px'; 
            wrapper.style.top = '200px';
            wrapper.style.width = '480px'; 

            const img = document.createElement('img');
            img.src = objectUrl;
            img.dataset.assetPath = assetPath;
            img.style.width = '100%'; img.style.height = '100%';
            img.style.display = 'block'; img.ondragstart = () => false;
            img.addEventListener('load', () => URL.revokeObjectURL(objectUrl), { once: true });
            img.addEventListener('error', () => URL.revokeObjectURL(objectUrl), { once: true });
            
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            
            wrapper.appendChild(img); wrapper.appendChild(handle);
            activeSlide.appendChild(wrapper);
            
            setupInteraction(wrapper, handle);
            selectImage(wrapper);
            showSaveButton();
        }

        // === ë“œë˜ê·¸/ë¦¬ì‚¬ì´ì¦ˆ ì¸í„°ë™ì…˜ ===
        function setupInteraction(element, handle) {
            element.addEventListener('mousedown', (e) => {
                if (document.body.classList.contains('is-fullscreen')) return;
                if (e.target === handle) return; 
                
                e.stopPropagation(); selectImage(element);
                
                const startX = e.clientX; 
                const startY = e.clientY;
                
                // í˜„ì¬ ìš”ì†Œì˜ left/top ê°’ (px)
                const startLeft = parseFloat(element.style.left || 0);
                const startTop = parseFloat(element.style.top || 0);

                function onMouseMove(e) {
                    // [ì¤‘ìš”] ë§ˆìš°ìŠ¤ ì´ë™ê±°ë¦¬ë¥¼ í˜„ì¬ ë°°ìœ¨(state.currentScale)ë¡œ ë‚˜ëˆ ì•¼
                    // ì‹¤ì œ 1280x720 ì¢Œí‘œê³„ì—ì„œì˜ ì´ë™ê±°ë¦¬ê°€ ë‚˜ì˜´
                    const dx = (e.clientX - startX) / state.currentScale;
                    const dy = (e.clientY - startY) / state.currentScale;

                    element.style.left = (startLeft + dx) + 'px';
                    element.style.top = (startTop + dy) + 'px';
                }
                function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    showSaveButton();
                }
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            handle.addEventListener('mousedown', (e) => {
                if (document.body.classList.contains('is-fullscreen')) return;

                e.stopPropagation(); e.preventDefault();
                const startX = e.clientX;
                const startWidth = parseFloat(getComputedStyle(element).width);
                const startHeight = parseFloat(getComputedStyle(element).height);
                const aspectRatio = startWidth / startHeight;

                function onMouseMove(e) {
                    // [ì¤‘ìš”] ë¦¬ì‚¬ì´ì¦ˆë„ ìŠ¤ì¼€ì¼ ë³´ì • í•„ìš”
                    const dx = (e.clientX - startX) / state.currentScale;
                    const newWidth = startWidth + dx;
                    
                    if (newWidth > 50) {
                        element.style.width = newWidth + 'px';
                        element.style.height = (newWidth / aspectRatio) + 'px';
                    }
                }
                function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    showSaveButton();
                }
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // === ì €ì¥/íŒ¨í‚¤ì§€ ===
        function selectImage(el) { deselectImage(); state.selectedImage = el; el.classList.add('selected'); }
        function deselectImage() { if (state.selectedImage) { state.selectedImage.classList.remove('selected'); state.selectedImage = null; } }
        function deleteSelectedImage() {
            if (!state.selectedImage) return;
            const img = state.selectedImage.querySelector('img[data-asset-path]');
            const assetPath = img ? img.dataset.assetPath : null;
            const iframe = state.selectedImage.querySelector('iframe[data-filename]');
            const htmlFileName = iframe ? iframe.dataset.filename : null;
            state.selectedImage.remove();
            state.selectedImage = null;
            removeImageAssetIfUnused(assetPath);
            removeHtmlAssetIfUnused(htmlFileName);
            showSaveButton();
        }
        function showSaveButton() {
            dom.saveBtn.style.display = 'block';
            dom.saveBtn.textContent = 'ğŸ“¦ íŒ¨í‚¤ì§€ ì €ì¥';
            scheduleThumbnailRefresh();
        }

        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder('utf-8');
        const crcTable = (() => {
            const table = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let k = 0; k < 8; k++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c >>> 0;
            }
            return table;
        })();

        function crc32(data) {
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i++) {
                const byte = data[i];
                crc = crcTable[(crc ^ byte) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        function toDosDateTime(date) {
            const year = Math.max(1980, date.getFullYear());
            const dosDate = ((year - 1980) << 9) | ((date.getMonth() + 1) << 5) | date.getDate();
            const dosTime = (date.getHours() << 11) | (date.getMinutes() << 5) | Math.floor(date.getSeconds() / 2);
            return { dosDate, dosTime };
        }

        async function toUint8Array(data) {
            if (data instanceof Uint8Array) return data;
            if (typeof data === 'string') return textEncoder.encode(data);
            if (data instanceof Blob) return new Uint8Array(await data.arrayBuffer());
            return new Uint8Array(0);
        }

        function buildZip(entries) {
            let offset = 0;
            const parts = [];
            const records = [];
            const { dosDate, dosTime } = toDosDateTime(new Date());

            for (const entry of entries) {
                const nameBytes = textEncoder.encode(entry.name);
                const data = entry.data;
                const crc = crc32(data);

                const localHeader = new Uint8Array(30 + nameBytes.length);
                const localView = new DataView(localHeader.buffer);
                localView.setUint32(0, 0x04034b50, true);
                localView.setUint16(4, 20, true);
                localView.setUint16(6, 0x0800, true);
                localView.setUint16(8, 0, true);
                localView.setUint16(10, dosTime, true);
                localView.setUint16(12, dosDate, true);
                localView.setUint32(14, crc, true);
                localView.setUint32(18, data.length, true);
                localView.setUint32(22, data.length, true);
                localView.setUint16(26, nameBytes.length, true);
                localView.setUint16(28, 0, true);
                localHeader.set(nameBytes, 30);

                parts.push(localHeader, data);
                records.push({ nameBytes, crc, size: data.length, offset, time: dosTime, date: dosDate });
                offset += localHeader.length + data.length;
            }

            const centralStart = offset;

            for (const record of records) {
                const centralHeader = new Uint8Array(46 + record.nameBytes.length);
                const view = new DataView(centralHeader.buffer);
                view.setUint32(0, 0x02014b50, true);
                view.setUint16(4, 20, true);
                view.setUint16(6, 20, true);
                view.setUint16(8, 0x0800, true);
                view.setUint16(10, 0, true);
                view.setUint16(12, record.time, true);
                view.setUint16(14, record.date, true);
                view.setUint32(16, record.crc, true);
                view.setUint32(20, record.size, true);
                view.setUint32(24, record.size, true);
                view.setUint16(28, record.nameBytes.length, true);
                view.setUint16(30, 0, true);
                view.setUint16(32, 0, true);
                view.setUint16(34, 0, true);
                view.setUint16(36, 0, true);
                view.setUint32(38, 0, true);
                view.setUint32(42, record.offset, true);
                centralHeader.set(record.nameBytes, 46);
                parts.push(centralHeader);
                offset += centralHeader.length;
            }

            const centralSize = offset - centralStart;
            const end = new Uint8Array(22);
            const endView = new DataView(end.buffer);
            endView.setUint32(0, 0x06054b50, true);
            endView.setUint16(4, 0, true);
            endView.setUint16(6, 0, true);
            endView.setUint16(8, records.length, true);
            endView.setUint16(10, records.length, true);
            endView.setUint32(12, centralSize, true);
            endView.setUint32(16, centralStart, true);
            endView.setUint16(20, 0, true);
            parts.push(end);

            return new Blob(parts, { type: 'application/zip' });
        }
        
        async function savePackage() {
            deselectImage(); 

            const missingAssets = getMissingAssets();
            if (missingAssets.length > 0) {
                const preview = missingAssets.slice(0, 10).join('\n');
                const more = missingAssets.length > 10 ? `\n...ì™¸ ${missingAssets.length - 10}ê°œ` : '';
                const proceed = confirm(`ë‹¤ìŒ ë¦¬ì†ŒìŠ¤ê°€ íŒ¨í‚¤ì§€ì— ì—†ìŠµë‹ˆë‹¤:\n${preview}${more}\n\nShift/Alt ë“œë˜ê·¸ë¡œ ì§€ì› íŒŒì¼ë§Œ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\nê·¸ë˜ë„ ì €ì¥í• ê¹Œìš”?`);
                if (!proceed) return;
            }

            const clone = document.documentElement.cloneNode(true);
            const iframes = clone.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                if (iframe.dataset.filename) {
                    iframe.setAttribute('src', './' + iframe.dataset.filename);
                }
            });

            const images = clone.querySelectorAll('img[data-asset-path]');
            images.forEach(img => {
                const assetPath = img.getAttribute('data-asset-path');
                if (assetPath) {
                    img.setAttribute('src', './' + assetPath);
                    img.removeAttribute('data-asset-path');
                }
            });

            const guides = clone.querySelectorAll('.guide-text');
            guides.forEach(g => {
                if (g.parentElement.querySelector('.draggable-img') || g.parentElement.querySelector('iframe')) g.remove();
            });

            const date = new Date();
            const timeString = `${date.getHours()}ì‹œ${date.getMinutes()}ë¶„`;
            const defaultBaseName = `Presentation_Package_${timeString}`;
            const defaultPackageName = `${defaultBaseName}.${CONFIG.PACKAGE_EXTENSION}`;
            let packageHandle = state.lastSaveHandle;
            let packageFileName = ensurePackageExtension(state.lastPackageFileName) || defaultPackageName;
            if (!packageFileName) packageFileName = defaultPackageName;

            if (!packageHandle) {
                try {
                    if (window.showSaveFilePicker) {
                        packageHandle = await window.showSaveFilePicker({
                            suggestedName: packageFileName,
                            types: [{ description: `Package (*.${CONFIG.PACKAGE_EXTENSION})`, accept: { 'application/zip': [`.${CONFIG.PACKAGE_EXTENSION}`] } }],
                        });
                        if (packageHandle && packageHandle.name) {
                            packageFileName = packageHandle.name;
                        }
                        state.lastSaveHandle = packageHandle;
                        state.lastPackageFileName = packageFileName;
                    }
                } catch (err) { console.log(err); }
            } else if (packageHandle.name) {
                packageFileName = packageHandle.name;
            }

            const baseTitle = stripExtensionFromName(packageFileName, CONFIG.PACKAGE_EXTENSION) || defaultBaseName;
            let mainFileName = `${baseTitle}.html`;
            if (state.packageFiles.has(mainFileName)) {
                mainFileName = uniquePath(mainFileName);
            }

            applyTitleToClone(clone, baseTitle);
            document.title = baseTitle;
            state.lastPackageFileName = packageFileName;
            const htmlContent = clone.outerHTML;

            const entries = [{ name: mainFileName, data: textEncoder.encode(htmlContent) }];
            for (const [name, blob] of state.packageFiles.entries()) {
                entries.push({ name, data: await toUint8Array(blob) });
            }

            const content = buildZip(entries);

            try {
                if (packageHandle) {
                    const writable = await packageHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    alert("íŒ¨í‚¤ì§€ íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!\nì••ì¶•ì„ í’€ë©´ ëª¨ë“  íŒŒì¼ì´ ë“¤ì–´ìˆìŠµë‹ˆë‹¤.");
                    return; 
                }
            } catch (err) { console.log(err); }

            const link = document.createElement('a');
            const url = URL.createObjectURL(content);
            link.href = url;
            link.download = packageFileName; 
            link.click();
            setTimeout(() => URL.revokeObjectURL(url), 0);
            alert("ë‹¤ìš´ë¡œë“œ í´ë”ì— íŒ¨í‚¤ì§€ íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!\nì••ì¶•ì„ í’€ê³  '" + mainFileName + "'ì„ ì‹¤í–‰í•˜ì„¸ìš”.");
        }

        // === ì „ì²´í™”ë©´ ===
        function startPresentation() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) elem.requestFullscreen();
            else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
            else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        }
        function exitPresentation() {
             if (document.exitFullscreen) document.exitFullscreen();
            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if (document.msExitFullscreen) document.msExitFullscreen();
        }

        // ì „ì²´í™”ë©´ ìƒíƒœ ë³€ê²½ ê°ì§€ -> ìŠ¤ì¼€ì¼ ì¬ì¡°ì •
        function handleFullscreenChange() {
            const isFs = document.fullscreenElement || document.webkitFullscreenElement;
            if (isFs) {
                document.body.classList.add('is-fullscreen');
            } else {
                document.body.classList.remove('is-fullscreen');
            }
            resizeStage(); // ìƒíƒœ ë³€ê²½ ì‹œ í¬ê¸° ì¬ê³„ì‚° (ì—¬ë°± ì œê±°/ë³µêµ¬)
        }
        
        // F11 í¬í•¨ resizeëŠ” ìƒë‹¨ resize ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬ë¨.

    </script>
</body>
</html>
